This part of code aims at analyzing a given LER formula. We have used Antlr4 to generate Scanner and Parser for our Grammar. 

You can use VCL ubuntu 14.04 to test our code

===========================================================================
===========================================================================

In order to let Antlr to recognize our grammar, we made some changes of the representation of LER.

Below is the summary of changes of LER notation. 

* use '$' to indicate the subscript of id. For example ID$t$
* use '∫' to indicate the lower bound and upper bound of index. For example ∫LOWER_BOUND, UPPER_BOUND∫
* use 'Γ' to represent Regular for loops 
* use 'Σ' to represent Summation
* use 'Π' to represent Product 
* use 'Ψ' to represent While loops and other irregular loops

===========================================================================
===========================================================================

Configuration of Environment

Make sure your machine has Java 11 installed. You can check your machine's java version by using command "java -version" and "javac -version"

Then install Altlr4, run follow command step by step (refer to here: https://github.com/antlr/antlr4/blob/master/doc/getting-started.md)

cd /usr/local/lib

curl -O https://www.antlr.org/download/antlr-4.13.1-complete.jar

Then add antlr-4.13.1-complete.jar to your CLASSPATH


export CLASSPATH=".:/usr/local/lib/antlr-4.13.1-complete.jar:$CLASSPATH"

alias antlr4='java -Xmx500M -cp "/usr/local/lib/antlr-4.13.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool'

alias grun='java -Xmx500M -cp "/usr/local/lib/antlr-4.13.1-complete.jar:$CLASSPATH" org.antlr.v4.gui.TestRig'



Then test installation use command "java org.antlr.v4.Tool".
If you see the something like below, the Antlr4 is already installed.

 ----------------------------------------------------------------------
|ANTLR Parser Generator  Version 4.13.1                                |
| -o ___       specify output directory where all output is generated  |
| -lib ___     specify location of grammars, tokens files              |
| -atn         generate rule augmented transition network diagrams     |
|...........                                                           |
|...........                                                           |
|----------------------------------------------------------------------|

===========================================================================
===========================================================================

Package Structure

LER: contains source code and LER grammar
testcases: input to our Scanner and Parser, i.e., the LER notiations
testResult: test result of test cases

===========================================================================
===========================================================================

Code Structure

Glory.g4 is the Antlr-style grammar of LER.

Glory.tokens, GloryBaseListener.java, GloryLexer.java. GloryLexer.tokens, GloryListener.java, GloryParser.java is generated by Antlr using our grammar.

Glory.java is the main program, it get the input of the testing data use listener pattern by calling "DirectiveListener" to parse the input and generate target code. Also, befor this process, it need to instantiate GloryLexer and GloryPasser

DirectiveListener.java is the collection of methods to generate target code. When the main program walk through the AST tree, corresponding method will get triggered when entering the node and exiting node




===========================================================================
===========================================================================

Compile:

Inside code folder, use the follow command

javac Glory*.java
javac Glory.java DirectiveListener.java

===========================================================================
===========================================================================

Test

If you want manually run the test, use the command below:

Inside code folder:

java Glory PATH_TO_TESTCASE

For example: if you want run case1.txt, you can use command below:

java Glory ../testcases/case1.txt

Then you can see the output in termianl

Also you can output parse tree in LISP notation:

grun Glory statement -tree
(Now enter something like the string below)
Σinter∫0,iter∫Σj∫0,N∫b[j]=a[2*i]
(now,do:)
^D
(The output:)
(statement (l Σ (forParam (id i n t e r) ∫ (lBound (number 0)) , (uBound (id i t e r)) ∫) (l Σ (forParam (id j) ∫ (lBound (number 0)) , (uBound (id N)) ∫) l)) (e (expression (term (factor (id b) [ (expression (term (factor (id j))) expressionPrime) ])) expressionPrime)) = (r (id a) [ (exprList (nonEmptyExprList (expression (term (term (factor (number 2))) (mulOp *) (factor (id i))) expressionPrime))) ]))
(That ^D means EOF on unix; it's ^Z in Windows.)

Auto-Test

If your machine has Python installed, you can use script "runAllTestCases.py" to run all test cases. This script will run all test cases and store the corresponding result in testResult folder. Run command:

python runAllTestCases.py

Then check result in testResult folder



===========================================================================
===========================================================================

Output:

The output is the code of the corresponding LER formula.

If the input is invalid of LER notation, it just get "Invalid Input" as the output result. And in terminal, it will get indications of why the input is invalid 





























